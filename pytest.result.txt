============================= test session starts =============================
platform win32 -- Python 3.8.7, pytest-6.2.4, py-1.10.0, pluggy-0.13.1 -- c:\dev\api_final_yatube\venv\scripts\python.exe
django: settings: yatube_api.settings (from ini)
rootdir: C:\Dev\api_final_yatube, configfile: pytest.ini, testpaths: tests/
plugins: django-4.4.0, pythonpath-0.7.3
collecting ... collected 32 items

tests/test_comment.py::TestCommentAPI::test_comments_not_authenticated FAILED [  3%]
tests/test_comment.py::TestCommentAPI::test_comment_single_not_authenticated FAILED [  6%]
tests/test_comment.py::TestCommentAPI::test_comments_not_found PASSED    [  9%]
tests/test_comment.py::TestCommentAPI::test_comments_get PASSED          [ 12%]
tests/test_comment.py::TestCommentAPI::test_comments_create PASSED       [ 15%]
tests/test_comment.py::TestCommentAPI::test_comment_get_current PASSED   [ 18%]
tests/test_comment.py::TestCommentAPI::test_comment_patch_current PASSED [ 21%]
tests/test_comment.py::TestCommentAPI::test_comment_delete_current PASSED [ 25%]
tests/test_follow.py::TestFollowAPI::test_follow_not_found PASSED        [ 28%]
tests/test_follow.py::TestFollowAPI::test_follow_not_auth PASSED         [ 31%]
tests/test_follow.py::TestFollowAPI::test_follow_get FAILED              [ 34%]
tests/test_follow.py::TestFollowAPI::test_follow_create FAILED           [ 37%]
tests/test_follow.py::TestFollowAPI::test_follow_search_filter FAILED    [ 40%]
tests/test_group.py::TestGroupAPI::test_group_not_found PASSED           [ 43%]
tests/test_group.py::TestGroupAPI::test_group_list_not_auth FAILED       [ 46%]
tests/test_group.py::TestGroupAPI::test_group_single_not_auth FAILED     [ 50%]
tests/test_group.py::TestGroupAPI::test_group_cannot_create PASSED       [ 53%]
tests/test_group.py::TestGroupAPI::test_group_get PASSED                 [ 56%]
tests/test_jwt.py::TestJWT::test_jwt_create__invalid_request_data FAILED [ 59%]
tests/test_jwt.py::TestJWT::test_jwt_create__valid_request_data FAILED   [ 62%]
tests/test_jwt.py::TestJWT::test_jwt_refresh__invalid_request_data FAILED [ 65%]
tests/test_jwt.py::TestJWT::test_jwt_refresh__valid_request_data FAILED  [ 68%]
tests/test_jwt.py::TestJWT::test_jwt_verify__invalid_request_data FAILED [ 71%]
tests/test_jwt.py::TestJWT::test_jwt_verify__valid_request_data FAILED   [ 75%]
tests/test_post.py::TestPostAPI::test_post_not_found PASSED              [ 78%]
tests/test_post.py::TestPostAPI::test_post_list_not_auth FAILED          [ 81%]
tests/test_post.py::TestPostAPI::test_post_single_not_auth FAILED        [ 84%]
tests/test_post.py::TestPostAPI::test_posts_get FAILED                   [ 87%]
tests/test_post.py::TestPostAPI::test_post_create PASSED                 [ 90%]
tests/test_post.py::TestPostAPI::test_post_get_current PASSED            [ 93%]
tests/test_post.py::TestPostAPI::test_post_patch_current PASSED          [ 96%]
tests/test_post.py::TestPostAPI::test_post_delete_current PASSED         [100%]

================================== FAILURES ===================================
_______________ TestCommentAPI.test_comments_not_authenticated ________________

self = <tests.test_comment.TestCommentAPI object at 0x0000022A6241E310>
client = <django.test.client.Client object at 0x0000022A62666BB0>
post = <Post: Тестовый пост 1>

    @pytest.mark.django_db(transaction=True)
    def test_comments_not_authenticated(self, client, post):
        response = client.get(f'/api/v1/posts/{post.id}/comments/')
    
        code = 200
>       assert response.status_code == code, (
            'Анонимный пользователь при запросе `/api/v1/posts/{post.id}/comments/` '
            f'должен получать ответ с кодом {code}'
        )
E       AssertionError: Анонимный пользователь при запросе `/api/v1/posts/{post.id}/comments/` должен получать ответ с кодом 200
E       assert 401 == 200
E         +401
E         -200

tests\test_comment.py:13: AssertionError
---------------------------- Captured stdout setup ----------------------------
Operations to perform:
  Synchronize unmigrated apps: api, djoser, messages, rest_framework, staticfiles
  Apply all migrations: admin, auth, contenttypes, posts, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying posts.0001_initial... OK
  Applying posts.0002_auto_20210925_1243... OK
  Applying posts.0003_auto_20210925_2026... OK
  Applying sessions.0001_initial... OK
---------------------------- Captured stderr setup ----------------------------
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Unauthorized: /api/v1/posts/1/comments/
____________ TestCommentAPI.test_comment_single_not_authenticated _____________

self = <tests.test_comment.TestCommentAPI object at 0x0000022A6241E2B0>
client = <django.test.client.Client object at 0x0000022A62FC5D00>
post = <Post: Тестовый пост 1>, comment_1_post = <Comment: Comment object (1)>

    @pytest.mark.django_db(transaction=True)
    def test_comment_single_not_authenticated(self, client, post, comment_1_post):
        response = client.get(f'/api/v1/posts/{post.id}/comments/{comment_1_post.id}/')
    
        code = 200
>       assert response.status_code == code, (
            'Анонимный пользователь при запросе `/api/v1/posts/{post.id}/comments/{comment.id}` '
            f'должен получать ответ с кодом {code}'
        )
E       AssertionError: Анонимный пользователь при запросе `/api/v1/posts/{post.id}/comments/{comment.id}` должен получать ответ с кодом 200
E       assert 401 == 200
E         +401
E         -200

tests\test_comment.py:23: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Unauthorized: /api/v1/posts/2/comments/1/
________________________ TestFollowAPI.test_follow_get ________________________

self = <tests.test_follow.TestFollowAPI object at 0x0000022A63283FD0>
user_client = <rest_framework.test.APIClient object at 0x0000022A63277430>
user = <User: TestUser>, follow_1 = <Follow: Follow object (5)>
follow_2 = <Follow: Follow object (6)>, follow_3 = <Follow: Follow object (7)>

    @pytest.mark.django_db(transaction=True)
    def test_follow_get(self, user_client, user, follow_1, follow_2, follow_3):
        response = user_client.get('/api/v1/follow/')
        assert response.status_code == 200, (
            'Проверьте, что при GET запросе `/api/v1/follow/` с токеном авторизации возвращается статус 200'
        )
    
        test_data = response.json()
    
        assert type(test_data) == list, (
            'Проверьте, что при GET запросе на `/api/v1/follow/` возвращается список'
        )
    
>       assert len(test_data) == Follow.objects.filter(following__username=user.username).count(), (
            'Проверьте, что при GET запросе на `/api/v1/follow/` возвращается список всех подписчиков пользователя'
        )
E       AssertionError: Проверьте, что при GET запросе на `/api/v1/follow/` возвращается список всех подписчиков пользователя
E       assert 3 == 1
E         +3
E         -1

tests\test_follow.py:45: AssertionError
______________________ TestFollowAPI.test_follow_create _______________________

self = <django.db.backends.utils.CursorWrapper object at 0x0000022A632E6040>
sql = 'INSERT INTO "posts_follow" ("user_id", "following_id") VALUES (%s, %s)'
params = [22, 24]
ignored_wrapper_args = (False, {'connection': <django.db.backends.sqlite3.base.DatabaseWrapper object at 0x0000022A6178AB20>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x0000022A632E6040>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)

venv\lib\site-packages\django\db\backends\utils.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000022A632B2280>
query = 'INSERT INTO "posts_follow" ("user_id", "following_id") VALUES (?, ?)'
params = [22, 24]

    def execute(self, query, params=None):
        if params is None:
            return Database.Cursor.execute(self, query)
        query = self.convert_query(query)
>       return Database.Cursor.execute(self, query, params)
E       sqlite3.IntegrityError: UNIQUE constraint failed: posts_follow.user_id, posts_follow.following_id

venv\lib\site-packages\django\db\backends\sqlite3\base.py:383: IntegrityError

The above exception was the direct cause of the following exception:

self = <tests.test_follow.TestFollowAPI object at 0x0000022A632A19A0>
user_client = <rest_framework.test.APIClient object at 0x0000022A632BB820>
follow_2 = <Follow: Follow object (8)>, follow_3 = <Follow: Follow object (9)>
user = <User: TestUser>, user_2 = <User: TestUser2>
another_user = <User: TestUserAnother>

    @pytest.mark.django_db(transaction=True)
    def test_follow_create(self, user_client, follow_2, follow_3, user, user_2, another_user):
        follow_count = Follow.objects.count()
    
        data = {}
        response = user_client.post('/api/v1/follow/', data=data)
        assert response.status_code == 400, (
            'Проверьте, что при POST запросе на `/api/v1/follow/` с неправильными данными возвращается статус 400'
        )
    
        data = {'following': another_user.username}
        response = user_client.post('/api/v1/follow/', data=data)
        assert response.status_code == 201, (
            'Проверьте, что при POST запросе на `/api/v1/follow/` с правильными данными возвращается статус 201'
        )
    
        test_data = response.json()
    
        msg_error = (
            'Проверьте, что при POST запросе на `/api/v1/follow/` возвращается словарь с данными новой подписки'
        )
        assert type(test_data) == dict, msg_error
        assert test_data.get('user') == user.username, msg_error
        assert test_data.get('following') == data['following'], msg_error
    
        assert follow_count + 1 == Follow.objects.count(), (
            'Проверьте, что при POST запросе на `/api/v1/follow/` создается подписка'
        )
    
>       response = user_client.post('/api/v1/follow/', data=data)

tests\test_follow.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\rest_framework\test.py:295: in post
    response = super().post(
venv\lib\site-packages\rest_framework\test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
venv\lib\site-packages\rest_framework\test.py:233: in generic
    return super().generic(
venv\lib\site-packages\django\test\client.py:422: in generic
    return self.request(**r)
venv\lib\site-packages\rest_framework\test.py:285: in request
    return super().request(**kwargs)
venv\lib\site-packages\rest_framework\test.py:237: in request
    request = super().request(**kwargs)
venv\lib\site-packages\django\test\client.py:503: in request
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:34: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:115: in _get_response
    response = self.process_exception_by_middleware(e, request)
venv\lib\site-packages\django\core\handlers\base.py:113: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\decorators\csrf.py:54: in wrapped_view
    return view_func(*args, **kwargs)
venv\lib\site-packages\rest_framework\viewsets.py:125: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\views.py:509: in dispatch
    response = self.handle_exception(exc)
venv\lib\site-packages\rest_framework\views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
venv\lib\site-packages\rest_framework\views.py:480: in raise_uncaught_exception
    raise exc
venv\lib\site-packages\rest_framework\views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\mixins.py:19: in create
    self.perform_create(serializer)
yatube_api\api\views.py:53: in perform_create
    serializer.save(user=self.request.user)
venv\lib\site-packages\rest_framework\serializers.py:205: in save
    self.instance = self.create(validated_data)
venv\lib\site-packages\rest_framework\serializers.py:939: in create
    instance = ModelClass._default_manager.create(**validated_data)
venv\lib\site-packages\django\db\models\manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:422: in create
    obj.save(force_insert=True, using=self.db)
venv\lib\site-packages\django\db\models\base.py:743: in save
    self.save_base(using=using, force_insert=force_insert,
venv\lib\site-packages\django\db\models\base.py:780: in save_base
    updated = self._save_table(
venv\lib\site-packages\django\db\models\base.py:873: in _save_table
    result = self._do_insert(cls._base_manager, using, fields, update_pk, raw)
venv\lib\site-packages\django\db\models\base.py:910: in _do_insert
    return manager._insert([self], fields=fields, return_id=update_pk,
venv\lib\site-packages\django\db\models\manager.py:82: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:1186: in _insert
    return query.get_compiler(using=using).execute_sql(return_id)
venv\lib\site-packages\django\db\models\sql\compiler.py:1377: in execute_sql
    cursor.execute(sql, params)
venv\lib\site-packages\django\db\backends\utils.py:67: in execute
    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)
venv\lib\site-packages\django\db\backends\utils.py:76: in _execute_with_wrappers
    return executor(sql, params, many, context)
venv\lib\site-packages\django\db\backends\utils.py:84: in _execute
    return self.cursor.execute(sql, params)
venv\lib\site-packages\django\db\utils.py:89: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
venv\lib\site-packages\django\db\backends\utils.py:84: in _execute
    return self.cursor.execute(sql, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x0000022A632B2280>
query = 'INSERT INTO "posts_follow" ("user_id", "following_id") VALUES (?, ?)'
params = [22, 24]

    def execute(self, query, params=None):
        if params is None:
            return Database.Cursor.execute(self, query)
        query = self.convert_query(query)
>       return Database.Cursor.execute(self, query, params)
E       django.db.utils.IntegrityError: UNIQUE constraint failed: posts_follow.user_id, posts_follow.following_id

venv\lib\site-packages\django\db\backends\sqlite3\base.py:383: IntegrityError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Bad Request: /api/v1/follow/
ERROR    django.request:log.py:222 Internal Server Error: /api/v1/follow/
Traceback (most recent call last):
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\backends\utils.py", line 84, in _execute
    return self.cursor.execute(sql, params)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\backends\sqlite3\base.py", line 383, in execute
    return Database.Cursor.execute(self, query, params)
sqlite3.IntegrityError: UNIQUE constraint failed: posts_follow.user_id, posts_follow.following_id

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\exception.py", line 34, in inner
    response = get_response(request)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 115, in _get_response
    response = self.process_exception_by_middleware(e, request)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 113, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\views\decorators\csrf.py", line 54, in wrapped_view
    return view_func(*args, **kwargs)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\viewsets.py", line 125, in view
    return self.dispatch(request, *args, **kwargs)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 509, in dispatch
    response = self.handle_exception(exc)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 480, in raise_uncaught_exception
    raise exc
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\mixins.py", line 19, in create
    self.perform_create(serializer)
  File "C:\Dev\api_final_yatube\yatube_api\api\views.py", line 53, in perform_create
    serializer.save(user=self.request.user)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 205, in save
    self.instance = self.create(validated_data)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 939, in create
    instance = ModelClass._default_manager.create(**validated_data)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\manager.py", line 82, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\query.py", line 422, in create
    obj.save(force_insert=True, using=self.db)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\base.py", line 743, in save
    self.save_base(using=using, force_insert=force_insert,
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\base.py", line 780, in save_base
    updated = self._save_table(
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\base.py", line 873, in _save_table
    result = self._do_insert(cls._base_manager, using, fields, update_pk, raw)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\base.py", line 910, in _do_insert
    return manager._insert([self], fields=fields, return_id=update_pk,
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\manager.py", line 82, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\query.py", line 1186, in _insert
    return query.get_compiler(using=using).execute_sql(return_id)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\models\sql\compiler.py", line 1377, in execute_sql
    cursor.execute(sql, params)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\backends\utils.py", line 67, in execute
    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\backends\utils.py", line 76, in _execute_with_wrappers
    return executor(sql, params, many, context)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\backends\utils.py", line 84, in _execute
    return self.cursor.execute(sql, params)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\utils.py", line 89, in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\backends\utils.py", line 84, in _execute
    return self.cursor.execute(sql, params)
  File "c:\dev\api_final_yatube\venv\lib\site-packages\django\db\backends\sqlite3\base.py", line 383, in execute
    return Database.Cursor.execute(self, query, params)
django.db.utils.IntegrityError: UNIQUE constraint failed: posts_follow.user_id, posts_follow.following_id
___________________ TestFollowAPI.test_follow_search_filter ___________________

self = <tests.test_follow.TestFollowAPI object at 0x0000022A63283610>
user_client = <rest_framework.test.APIClient object at 0x0000022A63C1EAC0>
follow_1 = <Follow: Follow object (11)>, follow_2 = <Follow: Follow object (12)>
follow_3 = <Follow: Follow object (13)>, follow_4 = <Follow: Follow object (14)>
follow_5 = <Follow: Follow object (15)>, user = <User: TestUser>
user_2 = <User: TestUser2>, another_user = <User: TestUserAnother>

    @pytest.mark.django_db(transaction=True)
    def test_follow_search_filter(self, user_client, follow_1, follow_2,
                                  follow_3, follow_4, follow_5,
                                  user, user_2, another_user):
    
        follow_user = Follow.objects.filter(user=user)
        follow_user_cnt = follow_user.count()
    
        response = user_client.get('/api/v1/follow/')
        assert response.status_code != 404, (
            'Страница `/api/v1/follow/` не найдена, проверьте этот адрес в *urls.py*'
        )
        assert response.status_code == 200, (
            'Страница `/api/v1/follow/` не работает, проверьте view-функцию'
        )
    
        test_data = response.json()
>       assert len(test_data) == follow_user_cnt, (
            'Проверьте, что при GET запросе на `/api/v1/follow/` возвращается список всех подписок пользователя'
        )
E       AssertionError: Проверьте, что при GET запросе на `/api/v1/follow/` возвращается список всех подписок пользователя
E       assert 5 == 2
E         +5
E         -2

tests\test_follow.py:126: AssertionError
____________________ TestGroupAPI.test_group_list_not_auth ____________________

self = <tests.test_group.TestGroupAPI object at 0x0000022A63245B20>
client = <django.test.client.Client object at 0x0000022A6329A5E0>
post = <Post: Тестовый пост 1>, group_1 = <Group: Группа 1>

    @pytest.mark.django_db(transaction=True)
    def test_group_list_not_auth(self, client, post, group_1):
        response = client.get('/api/v1/groups/')
>       assert response.status_code == 200, (
            'Проверьте, что `/api/v1/groups/` при запросе без токена возвращаете статус 200'
        )
E       AssertionError: Проверьте, что `/api/v1/groups/` при запросе без токена возвращаете статус 200
E       assert 401 == 200
E         +401
E         -200

tests\test_group.py:19: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Unauthorized: /api/v1/groups/
___________________ TestGroupAPI.test_group_single_not_auth ___________________

self = <tests.test_group.TestGroupAPI object at 0x0000022A632993D0>
client = <django.test.client.Client object at 0x0000022A632A1130>
group_1 = <Group: Группа 1>

    @pytest.mark.django_db(transaction=True)
    def test_group_single_not_auth(self, client, group_1):
        response = client.get(f'/api/v1/groups/{group_1.id}/')
>       assert response.status_code == 200, (
            'Проверьте, что `/api/v1/groups/{group.id}/` при запросе без токена возвращаете статус 200'
        )
E       AssertionError: Проверьте, что `/api/v1/groups/{group.id}/` при запросе без токена возвращаете статус 200
E       assert 401 == 200
E         +401
E         -200

tests\test_group.py:26: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Unauthorized: /api/v1/groups/12/
________________ TestJWT.test_jwt_create__invalid_request_data ________________

self = <tests.test_jwt.TestJWT object at 0x0000022A63582EE0>
client = <django.test.client.Client object at 0x0000022A634E24F0>
user = <User: TestUser>

    @pytest.mark.django_db(transaction=True)
    def test_jwt_create__invalid_request_data(self, client, user):
        url = self.url_create
        response = client.post(url)
        code_expected = 400
>       assert response.status_code == code_expected, (
            f'Убедитесь, что при запросе `{url}` без параметров, '
            f'возвращается код {code_expected}'
        )
E       AssertionError: Убедитесь, что при запросе `/api/v1/jwt/create/` без параметров, возвращается код 400
E       assert 404 == 400
E         +404
E         -400

tests\test_jwt.py:17: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Not Found: /api/v1/jwt/create/
_________________ TestJWT.test_jwt_create__valid_request_data _________________

self = <tests.test_jwt.TestJWT object at 0x0000022A63273130>
client = <django.test.client.Client object at 0x0000022A6321FEE0>
user = <User: TestUser>

    @pytest.mark.django_db(transaction=True)
    def test_jwt_create__valid_request_data(self, client, user):
        url = self.url_create
        valid_data = {
            'username': user.username,
            'password': '1234567'
        }
        response = client.post(url, data=valid_data)
        code_expected = 200
>       assert response.status_code == code_expected, (
            f'Убедитесь, что при запросе `{url}` с валидными данными, '
            f'возвращается код {code_expected}'
        )
E       AssertionError: Убедитесь, что при запросе `/api/v1/jwt/create/` с валидными данными, возвращается код 200
E       assert 404 == 200
E         +404
E         -200

tests\test_jwt.py:74: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Not Found: /api/v1/jwt/create/
_______________ TestJWT.test_jwt_refresh__invalid_request_data ________________

self = <tests.test_jwt.TestJWT object at 0x0000022A632735B0>
client = <django.test.client.Client object at 0x0000022A6314CC10>

    @pytest.mark.django_db(transaction=True)
    def test_jwt_refresh__invalid_request_data(self, client):
        url = self.url_refresh
    
        response = client.post(url)
        code_expected = 400
>       assert response.status_code == code_expected, (
            f'Убедитесь, что при запросе `{url}` без параметров, '
            f'возвращается код {code_expected}'
        )
E       AssertionError: Убедитесь, что при запросе `/api/v1/jwt/refresh/` без параметров, возвращается код 400
E       assert 404 == 400
E         +404
E         -400

tests\test_jwt.py:92: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Not Found: /api/v1/jwt/refresh/
________________ TestJWT.test_jwt_refresh__valid_request_data _________________

self = <tests.test_jwt.TestJWT object at 0x0000022A634FF8E0>
client = <django.test.client.Client object at 0x0000022A6380CA30>
user = <User: TestUser>

    @pytest.mark.django_db(transaction=True)
    def test_jwt_refresh__valid_request_data(self, client, user):
        url = self.url_refresh
        valid_data = {
            'username': user.username,
            'password': '1234567'
        }
        response = client.post(self.url_create, data=valid_data)
>       token_refresh = response.json().get('refresh')

tests\test_jwt.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000022A6380CA30>
response = <HttpResponseNotFound status_code=404, "text/html">, extra = {}

    def _parse_json(self, response, **extra):
        if not hasattr(response, '_json'):
            if not JSON_CONTENT_TYPE_RE.match(response.get('Content-Type')):
>               raise ValueError(
                    'Content-Type header is "{0}", not "application/json"'
                    .format(response.get('Content-Type'))
                )
E               ValueError: Content-Type header is "text/html", not "application/json"

venv\lib\site-packages\django\test\client.py:666: ValueError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Not Found: /api/v1/jwt/create/
________________ TestJWT.test_jwt_verify__invalid_request_data ________________

self = <tests.test_jwt.TestJWT object at 0x0000022A63C9D4C0>
client = <django.test.client.Client object at 0x0000022A636DD2E0>

    @pytest.mark.django_db(transaction=True)
    def test_jwt_verify__invalid_request_data(self, client):
        url = self.url_verify
    
        response = client.post(url)
        code_expected = 400
>       assert response.status_code == code_expected, (
            f'Убедитесь, что при запросе `{url}` без параметров, '
            f'возвращается код {code_expected}'
        )
E       AssertionError: Убедитесь, что при запросе `/api/v1/jwt/verify/` без параметров, возвращается код 400
E       assert 404 == 400
E         +404
E         -400

tests\test_jwt.py:140: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Not Found: /api/v1/jwt/verify/
_________________ TestJWT.test_jwt_verify__valid_request_data _________________

self = <tests.test_jwt.TestJWT object at 0x0000022A6264FE20>
client = <django.test.client.Client object at 0x0000022A63266AF0>
user = <User: TestUser>

    @pytest.mark.django_db(transaction=True)
    def test_jwt_verify__valid_request_data(self, client, user):
        url = self.url_verify
        valid_data = {
            'username': user.username,
            'password': '1234567'
        }
        response = client.post(self.url_create, data=valid_data)
>       token_access = response.json().get('access')

tests\test_jwt.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000022A63266AF0>
response = <HttpResponseNotFound status_code=404, "text/html">, extra = {}

    def _parse_json(self, response, **extra):
        if not hasattr(response, '_json'):
            if not JSON_CONTENT_TYPE_RE.match(response.get('Content-Type')):
>               raise ValueError(
                    'Content-Type header is "{0}", not "application/json"'
                    .format(response.get('Content-Type'))
                )
E               ValueError: Content-Type header is "text/html", not "application/json"

venv\lib\site-packages\django\test\client.py:666: ValueError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Not Found: /api/v1/jwt/create/
_____________________ TestPostAPI.test_post_list_not_auth _____________________

self = <tests.test_post.TestPostAPI object at 0x0000022A63271C70>
client = <django.test.client.Client object at 0x0000022A63223DC0>
post = <Post: Тестовый пост 1>

    @pytest.mark.django_db(transaction=True)
    def test_post_list_not_auth(self, client, post):
        response = client.get('/api/v1/posts/')
    
>       assert response.status_code == 200, (
            'Проверьте, что на `/api/v1/posts/` при запросе без токена возвращаете статус 200'
        )
E       AssertionError: Проверьте, что на `/api/v1/posts/` при запросе без токена возвращаете статус 200
E       assert 401 == 200
E         +401
E         -200

tests\test_post.py:20: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Unauthorized: /api/v1/posts/
____________________ TestPostAPI.test_post_single_not_auth ____________________

self = <tests.test_post.TestPostAPI object at 0x0000022A63C9D0D0>
client = <django.test.client.Client object at 0x0000022A632266A0>
post = <Post: Тестовый пост 1>

    @pytest.mark.django_db(transaction=True)
    def test_post_single_not_auth(self, client, post):
        response = client.get(f'/api/v1/posts/{post.id}/')
    
>       assert response.status_code == 200, (
            'Проверьте, что на `/api/v1/posts/{post.id}/` при запросе без токена возвращаете статус 200'
        )
E       AssertionError: Проверьте, что на `/api/v1/posts/{post.id}/` при запросе без токена возвращаете статус 200
E       assert 401 == 200
E         +401
E         -200

tests\test_post.py:28: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:222 Unauthorized: /api/v1/posts/17/
_________________________ TestPostAPI.test_posts_get __________________________

self = <tests.test_post.TestPostAPI object at 0x0000022A634FFE80>
user_client = <rest_framework.test.APIClient object at 0x0000022A632462B0>
post = <Post: Тестовый пост 1>, another_post = <Post: Тестовый пост 2>

    @pytest.mark.django_db(transaction=True)
    def test_posts_get(self, user_client, post, another_post):
        response = user_client.get('/api/v1/posts/')
        assert response.status_code == 200, (
            'Проверьте, что при GET запросе `/api/v1/posts/` с токеном авторизации возвращаетсся статус 200'
        )
    
        test_data = response.json()
    
>       assert type(test_data) == list, (
            'Проверьте, что при GET запросе на `/api/v1/posts/` возвращается список'
        )
E       AssertionError: Проверьте, что при GET запросе на `/api/v1/posts/` возвращается список
E       assert <class 'dict'> == <class 'list'>
E         +<class 'dict'>
E         -<class 'list'>

tests\test_post.py:41: AssertionError
=========================== short test summary info ===========================
FAILED tests/test_comment.py::TestCommentAPI::test_comments_not_authenticated
FAILED tests/test_comment.py::TestCommentAPI::test_comment_single_not_authenticated
FAILED tests/test_follow.py::TestFollowAPI::test_follow_get - AssertionError:...
FAILED tests/test_follow.py::TestFollowAPI::test_follow_create - django.db.ut...
FAILED tests/test_follow.py::TestFollowAPI::test_follow_search_filter - Asser...
FAILED tests/test_group.py::TestGroupAPI::test_group_list_not_auth - Assertio...
FAILED tests/test_group.py::TestGroupAPI::test_group_single_not_auth - Assert...
FAILED tests/test_jwt.py::TestJWT::test_jwt_create__invalid_request_data - As...
FAILED tests/test_jwt.py::TestJWT::test_jwt_create__valid_request_data - Asse...
FAILED tests/test_jwt.py::TestJWT::test_jwt_refresh__invalid_request_data - A...
FAILED tests/test_jwt.py::TestJWT::test_jwt_refresh__valid_request_data - Val...
FAILED tests/test_jwt.py::TestJWT::test_jwt_verify__invalid_request_data - As...
FAILED tests/test_jwt.py::TestJWT::test_jwt_verify__valid_request_data - Valu...
FAILED tests/test_post.py::TestPostAPI::test_post_list_not_auth - AssertionEr...
FAILED tests/test_post.py::TestPostAPI::test_post_single_not_auth - Assertion...
FAILED tests/test_post.py::TestPostAPI::test_posts_get - AssertionError: Пров...
======================== 16 failed, 16 passed in 8.56s ========================
